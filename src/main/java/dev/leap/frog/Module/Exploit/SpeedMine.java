package dev.leap.frog.Module.Exploit;

import dev.leap.frog.Event.Movement.EventPlayerBreakBlock;
import dev.leap.frog.Manager.UtilManager;
import dev.leap.frog.Module.Module;
import dev.leap.frog.Settings.Setting;
import dev.leap.frog.Util.Render.Chatutil;
import dev.leap.frog.Util.Render.Renderutil;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.Entity;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;
import org.lwjgl.opengl.GL11;

public class SpeedMine extends Module {

    public SpeedMine() {
        super("Speed Mine", "Attempts to speed up digging", Type.EXPLOIT);
    }

    Setting<Mode> mode = create("Mode", Mode.Normal);
    Setting<Boolean> render = create("Render", true);
    Setting<Boolean> pickaxeOnly = create("Pickaxe only", false);

    private boolean breaking = false;
    private RayTraceResult ray;
    private BlockPos renderPos;

    private enum Mode {
        Normal,
        Spoof,
        Bypass,
        Instant
    }

    @Override
    public void onUpdate() {
        if(UtilManager.nullCheck()) return;

        ray = mc.objectMouseOver;
        if(ray.typeOfHit == RayTraceResult.Type.BLOCK && mc.gameSettings.keyBindAttack.isKeyDown()) {
                breaking = true;
        }

        if(this.mode.getValue() == Mode.Normal) {
            mc.playerController.blockHitDelay = 0;
        }
    }

    @EventHandler
    private Listener<EventPlayerBreakBlock> breakBlockListener = new Listener<>(event -> {

        if(event.getPos() == null) return;
        renderPos = event.getPos();

        if(mode.getValue() == Mode.Spoof) {
           // if(!canBreak(event.getPos())) { // deprecated???
           //     return;
           // }
            if(pickaxeOnly.getValue() && !(mc.player.getHeldItemMainhand().getItem() instanceof ItemPickaxe)) {
                return;
            }
            mc.player.swingArm(EnumHand.MAIN_HAND);
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), event.getFacing()));
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getPos(), event.getFacing()));
        } else if(mode.getValue() == Mode.Instant) {
            if(pickaxeOnly.getValue() && !(mc.player.getHeldItemMainhand().getItem() instanceof ItemPickaxe)) {
                return;
            }
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), event.getFacing()));
        } else if(mode.getValue() == Mode.Bypass) {
            if(pickaxeOnly.getValue() && !(mc.player.getHeldItemMainhand().getItem() instanceof ItemPickaxe)) {
                return;
            }

            mc.playerController.curBlockDamageMP += 1.0f;
        }
    });

    @Override
    public void onRender() {
        if(render.getValue()) {
            Vec3d position = interpolateEntity(mc.player, mc.getRenderPartialTicks());

            mc.renderGlobal.damagedBlocks.forEach(((integer, blockProgress) -> {
                Renderutil.drawBoundingBoxBlockPos(blockProgress.getPosition(), 1, 234, 200, 245, 255);
            }));
        }
    }

    public static Vec3d interpolateEntity(Entity entity, float time) {
        return new Vec3d(entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * time, entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * time, entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * time);
    }

    private boolean isBreakable(BlockPos pos) {
        IBlockState state = mc.world.getBlockState(pos);
        Block block = state.getBlock();
        return ray.getBlockPos() == pos && !(block == Blocks.BEDROCK);
    }

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();

        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

}
