package dev.leap.frog.Module.Exploit;

import dev.leap.frog.Event.LeapFrogEvent;
import dev.leap.frog.Event.Network.EventPacket;
import dev.leap.frog.Module.Module;
import dev.leap.frog.Settings.Settings;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketKeepAlive;
import net.minecraft.network.play.server.SPacketKeepAlive;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedDeque;

public class Pingspoof extends Module {

    public Pingspoof() {
        super("Ping Spoof", "Spoofs packets so it looks like player is lagging", Type.EXPLOIT);
    }

    Settings delay = create("Delay", "Delay", 50, 1, 1000);

    private Queue<Packet<?>> packetQueue = new ConcurrentLinkedDeque<>(); // took queue approach but could change it up
    private Timer timer = new Timer();
    private boolean receive;

    @Override
    public void onUpdate() {
        if(mc.player != null || mc.world != null) {
            queuePacket();
        }
    }

    @Override
    public void onDisable() {
        queuePacket();
    }

    @EventHandler
    private Listener<EventPacket.ReceivePacket> packetListener = new Listener<>(event -> {

        if(event.getPacket() instanceof SPacketKeepAlive && mc.player.isEntityAlive() && !mc.isSingleplayer() && event.getEra() == LeapFrogEvent.Era.PRE) {
            packetQueue.add(event.getPacket());
            event.cancel();

           long packetID = ((SPacketKeepAlive) event.getPacket()).getId();
           SPacketKeepAlive packet = (SPacketKeepAlive) event.getPacket();



        }
    });

    private boolean isValidPing() {
        return mc.player == null || mc.world == null || mc.isSingleplayer() || mc.player.isEntityAlive();
    }

    private void queuePacket() {
        if(!isValidPing() && timer.passedS(delay.getValue(1)) || timer.passedMs(delay.getValue(1))) {
            double queued = getIncremental(Math.random() * 10.0, 1.0);
            receive = false;
            for (int i = 0; i < queued; ++i) {
                final Packet<?> packet = packetQueue.poll();
                if (packet != null) {
                    mc.player.connection.sendPacket((Packet)packet);
                }
            }

            mc.player.connection.sendPacket(new CPacketKeepAlive(100000L));

            timer.reset();
            receive = true;
        }
    }

    public double getIncremental(final double val, final double inc) {
        final double one = 1.0 / inc;
        return Math.round(val * one) / one;
    }

    class Timer {
        private long time;

        public Timer() {
            this.time = -1L;
        }

        public boolean passedS(final double s) {
            return this.passedMs((long)s * 1000L);
        }

        public boolean passedDms(final double dms) {
            return this.passedMs((long)dms * 10L);
        }

        public boolean passedDs(final double ds) {
            return this.passedMs((long)ds * 100L);
        }

        public boolean passedMs(final long ms) {
            return this.passedNS(this.convertToNS(ms));
        }

        public void setMs(final long ms) {
            this.time = System.nanoTime() - this.convertToNS(ms);
        }

        public boolean passedNS(final long ns) {
            return System.nanoTime() - this.time >= ns;
        }

        public long getPassedTimeMs() {
            return this.getMs(System.nanoTime() - this.time);
        }

        public Timer reset() {
            this.time = System.nanoTime();
            return this;
        }

        public long getMs(final long time) {
            return time / 1000000L;
        }

        public long convertToNS(final long time) {
            return time * 1000000L;
        }
    }

}
